{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar crypto = require('crypto'),\n    nodes = require('../nodes');\n\nvar MemoryCache = module.exports = function (options) {\n  options = options || {};\n  this.limit = options['cache limit'] || 256;\n  this._cache = {};\n  this.length = 0;\n  this.head = this.tail = null;\n};\n/**\n * Set cache item with given `key` to `value`.\n *\n * @param {String} key\n * @param {Object} value\n * @api private\n */\n\n\nMemoryCache.prototype.set = function (key, value) {\n  var clone = value.clone(),\n      item;\n  clone.filename = nodes.filename;\n  clone.lineno = nodes.lineno;\n  clone.column = nodes.column;\n  item = {\n    key: key,\n    value: clone\n  };\n  this._cache[key] = item;\n\n  if (this.tail) {\n    this.tail.next = item;\n    item.prev = this.tail;\n  } else {\n    this.head = item;\n  }\n\n  this.tail = item;\n  if (this.length++ == this.limit) this.purge();\n};\n/**\n * Get cache item with given `key`.\n *\n * @param {String} key\n * @return {Object}\n * @api private\n */\n\n\nMemoryCache.prototype.get = function (key) {\n  var item = this._cache[key],\n      val = item.value.clone();\n  if (item == this.tail) return val;\n\n  if (item.next) {\n    if (item == this.head) this.head = item.next;\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) item.prev.next = item.next;\n  item.next = null;\n  item.prev = this.tail;\n  if (this.tail) this.tail.next = item;\n  this.tail = item;\n  return val;\n};\n/**\n * Check if cache has given `key`.\n *\n * @param {String} key\n * @return {Boolean}\n * @api private\n */\n\n\nMemoryCache.prototype.has = function (key) {\n  return !!this._cache[key];\n};\n/**\n * Generate key for the source `str` with `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\n\nMemoryCache.prototype.key = function (str, options) {\n  var hash = crypto.createHash('sha1');\n  hash.update(str + options.prefix);\n  return hash.digest('hex');\n};\n/**\n * Remove the oldest item from the cache.\n *\n * @api private\n */\n\n\nMemoryCache.prototype.purge = function () {\n  var item = this.head;\n\n  if (this.head.next) {\n    this.head = this.head.next;\n    this.head.prev = null;\n  }\n\n  this._cache[item.key] = item.prev = item.next = null;\n  this.length--;\n};","map":{"version":3,"sources":["/Users/timurmishiev/burger-hub-frontend/node_modules/stylus/lib/cache/memory.js"],"names":["crypto","require","nodes","MemoryCache","module","exports","options","limit","_cache","length","head","tail","prototype","set","key","value","clone","item","filename","lineno","column","next","prev","purge","get","val","has","str","hash","createHash","update","prefix","digest"],"mappings":"AAAA;AACA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;AAAA,IACIC,KAAK,GAAGD,OAAO,CAAC,UAAD,CADnB;;AAGA,IAAIE,WAAW,GAAGC,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AACnDA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,OAAKC,KAAL,GAAaD,OAAO,CAAC,aAAD,CAAP,IAA0B,GAAvC;AACA,OAAKE,MAAL,GAAc,EAAd;AACA,OAAKC,MAAL,GAAc,CAAd;AACA,OAAKC,IAAL,GAAY,KAAKC,IAAL,GAAY,IAAxB;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAR,WAAW,CAACS,SAAZ,CAAsBC,GAAtB,GAA4B,UAASC,GAAT,EAAcC,KAAd,EAAqB;AAC/C,MAAIC,KAAK,GAAGD,KAAK,CAACC,KAAN,EAAZ;AAAA,MACIC,IADJ;AAGAD,EAAAA,KAAK,CAACE,QAAN,GAAiBhB,KAAK,CAACgB,QAAvB;AACAF,EAAAA,KAAK,CAACG,MAAN,GAAejB,KAAK,CAACiB,MAArB;AACAH,EAAAA,KAAK,CAACI,MAAN,GAAelB,KAAK,CAACkB,MAArB;AACAH,EAAAA,IAAI,GAAG;AAAEH,IAAAA,GAAG,EAAEA,GAAP;AAAYC,IAAAA,KAAK,EAAEC;AAAnB,GAAP;AACA,OAAKR,MAAL,CAAYM,GAAZ,IAAmBG,IAAnB;;AAEA,MAAI,KAAKN,IAAT,EAAe;AACb,SAAKA,IAAL,CAAUU,IAAV,GAAiBJ,IAAjB;AACAA,IAAAA,IAAI,CAACK,IAAL,GAAY,KAAKX,IAAjB;AACD,GAHD,MAGO;AACL,SAAKD,IAAL,GAAYO,IAAZ;AACD;;AAED,OAAKN,IAAL,GAAYM,IAAZ;AACA,MAAI,KAAKR,MAAL,MAAiB,KAAKF,KAA1B,EAAiC,KAAKgB,KAAL;AAClC,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEApB,WAAW,CAACS,SAAZ,CAAsBY,GAAtB,GAA4B,UAASV,GAAT,EAAc;AACxC,MAAIG,IAAI,GAAG,KAAKT,MAAL,CAAYM,GAAZ,CAAX;AAAA,MACIW,GAAG,GAAGR,IAAI,CAACF,KAAL,CAAWC,KAAX,EADV;AAGA,MAAIC,IAAI,IAAI,KAAKN,IAAjB,EAAuB,OAAOc,GAAP;;AACvB,MAAIR,IAAI,CAACI,IAAT,EAAe;AACb,QAAIJ,IAAI,IAAI,KAAKP,IAAjB,EAAuB,KAAKA,IAAL,GAAYO,IAAI,CAACI,IAAjB;AACvBJ,IAAAA,IAAI,CAACI,IAAL,CAAUC,IAAV,GAAiBL,IAAI,CAACK,IAAtB;AACD;;AACD,MAAIL,IAAI,CAACK,IAAT,EAAeL,IAAI,CAACK,IAAL,CAAUD,IAAV,GAAiBJ,IAAI,CAACI,IAAtB;AAEfJ,EAAAA,IAAI,CAACI,IAAL,GAAY,IAAZ;AACAJ,EAAAA,IAAI,CAACK,IAAL,GAAY,KAAKX,IAAjB;AAEA,MAAI,KAAKA,IAAT,EAAe,KAAKA,IAAL,CAAUU,IAAV,GAAiBJ,IAAjB;AACf,OAAKN,IAAL,GAAYM,IAAZ;AAEA,SAAOQ,GAAP;AACD,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAtB,WAAW,CAACS,SAAZ,CAAsBc,GAAtB,GAA4B,UAASZ,GAAT,EAAc;AACxC,SAAO,CAAC,CAAC,KAAKN,MAAL,CAAYM,GAAZ,CAAT;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAX,WAAW,CAACS,SAAZ,CAAsBE,GAAtB,GAA4B,UAASa,GAAT,EAAcrB,OAAd,EAAuB;AACjD,MAAIsB,IAAI,GAAG5B,MAAM,CAAC6B,UAAP,CAAkB,MAAlB,CAAX;AACAD,EAAAA,IAAI,CAACE,MAAL,CAAYH,GAAG,GAAGrB,OAAO,CAACyB,MAA1B;AACA,SAAOH,IAAI,CAACI,MAAL,CAAY,KAAZ,CAAP;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AAEA7B,WAAW,CAACS,SAAZ,CAAsBW,KAAtB,GAA8B,YAAW;AACvC,MAAIN,IAAI,GAAG,KAAKP,IAAhB;;AAEA,MAAI,KAAKA,IAAL,CAAUW,IAAd,EAAoB;AAClB,SAAKX,IAAL,GAAY,KAAKA,IAAL,CAAUW,IAAtB;AACA,SAAKX,IAAL,CAAUY,IAAV,GAAiB,IAAjB;AACD;;AAED,OAAKd,MAAL,CAAYS,IAAI,CAACH,GAAjB,IAAwBG,IAAI,CAACK,IAAL,GAAYL,IAAI,CAACI,IAAL,GAAY,IAAhD;AACA,OAAKZ,MAAL;AACD,CAVD","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar crypto = require('crypto')\n  , nodes = require('../nodes');\n\nvar MemoryCache = module.exports = function(options) {\n  options = options || {};\n  this.limit = options['cache limit'] || 256;\n  this._cache = {};\n  this.length = 0;\n  this.head = this.tail = null;\n};\n\n/**\n * Set cache item with given `key` to `value`.\n *\n * @param {String} key\n * @param {Object} value\n * @api private\n */\n\nMemoryCache.prototype.set = function(key, value) {\n  var clone = value.clone()\n    , item;\n\n  clone.filename = nodes.filename;\n  clone.lineno = nodes.lineno;\n  clone.column = nodes.column;\n  item = { key: key, value: clone };\n  this._cache[key] = item;\n\n  if (this.tail) {\n    this.tail.next = item;\n    item.prev = this.tail;\n  } else {\n    this.head = item;\n  }\n\n  this.tail = item;\n  if (this.length++ == this.limit) this.purge();\n};\n\n/**\n * Get cache item with given `key`.\n *\n * @param {String} key\n * @return {Object}\n * @api private\n */\n\nMemoryCache.prototype.get = function(key) {\n  var item = this._cache[key]\n    , val = item.value.clone();\n\n  if (item == this.tail) return val;\n  if (item.next) {\n    if (item == this.head) this.head = item.next;\n    item.next.prev = item.prev;\n  }\n  if (item.prev) item.prev.next = item.next;\n\n  item.next = null;\n  item.prev = this.tail;\n\n  if (this.tail) this.tail.next = item;\n  this.tail = item;\n\n  return val;\n};\n\n/**\n * Check if cache has given `key`.\n *\n * @param {String} key\n * @return {Boolean}\n * @api private\n */\n\nMemoryCache.prototype.has = function(key) {\n  return !!this._cache[key];\n};\n\n/**\n * Generate key for the source `str` with `options`.\n *\n * @param {String} str\n * @param {Object} options\n * @return {String}\n * @api private\n */\n\nMemoryCache.prototype.key = function(str, options) {\n  var hash = crypto.createHash('sha1');\n  hash.update(str + options.prefix);\n  return hash.digest('hex');\n};\n\n/**\n * Remove the oldest item from the cache.\n *\n * @api private\n */\n\nMemoryCache.prototype.purge = function() {\n  var item = this.head;\n\n  if (this.head.next) {\n    this.head = this.head.next;\n    this.head.prev = null;\n  }\n\n  this._cache[item.key] = item.prev = item.next = null;\n  this.length--;\n};\n"]},"metadata":{},"sourceType":"script"}