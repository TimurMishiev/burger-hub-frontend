{"ast":null,"code":"/*!\n * Stylus - middleware\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar stylus = require('./stylus'),\n    semver = require('semver'),\n    fs = require('fs'),\n    url = require('url'),\n    dirname = require('path').dirname,\n    join = require('path').join,\n    sep = require('path').sep,\n    debug = require('debug')('stylus:middleware'),\n    mkdir = semver.satisfies(process.version, '>=10.12.0') ? fs.mkdir : require('mkdirp');\n/**\n * Import map.\n */\n\n\nvar imports = {};\n/**\n * Return Connect middleware with the given `options`.\n *\n * Options:\n *\n *    `force`     Always re-compile\n *    `src`       Source directory used to find .styl files,\n *                a string or function accepting `(path)` of request.\n *    `dest`      Destination directory used to output .css files,\n *                a string or function accepting `(path)` of request,\n *                when undefined defaults to `src`.\n *    `compile`   Custom compile function, accepting the arguments\n *                `(str, path)`.\n *    `compress`  Whether the output .css files should be compressed\n *    `firebug`   Emits debug infos in the generated CSS that can\n *                be used by the FireStylus Firebug plugin\n *    `linenos`   Emits comments in the generated CSS indicating\n *                the corresponding Stylus line\n *    'sourcemap' Generates a sourcemap in sourcemaps v3 format\n *\n * Examples:\n *\n * Here we set up the custom compile function so that we may\n * set the `compress` option, or define additional functions.\n *\n * By default the compile function simply sets the `filename`\n * and renders the CSS.\n *\n *      function compile(str, path) {\n *        return stylus(str)\n *          .set('filename', path)\n *          .set('compress', true);\n *      }\n *\n * Pass the middleware to Connect, grabbing .styl files from this directory\n * and saving .css files to _./public_. Also supplying our custom `compile` function.\n *\n * Following that we have a `static()` layer setup to serve the .css\n * files generated by Stylus.\n *\n *      var app = connect();\n *\n *      app.middleware({\n *          src: __dirname\n *        , dest: __dirname + '/public'\n *        , compile: compile\n *      })\n *\n *      app.use(connect.static(__dirname + '/public'));\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function (options) {\n  options = options || {}; // Accept src/dest dir\n\n  if ('string' == typeof options) {\n    options = {\n      src: options\n    };\n  } // Force compilation\n\n\n  var force = options.force; // Source dir required\n\n  var src = options.src;\n  if (!src) throw new Error('stylus.middleware() requires \"src\" directory'); // Default dest dir to source\n\n  var dest = options.dest || src; // Default compile callback\n\n  options.compile = options.compile || function (str, path) {\n    // inline sourcemap\n    if (options.sourcemap) {\n      if ('boolean' == typeof options.sourcemap) options.sourcemap = {};\n      options.sourcemap.inline = true;\n    }\n\n    return stylus(str).set('filename', path).set('compress', options.compress).set('firebug', options.firebug).set('linenos', options.linenos).set('sourcemap', options.sourcemap);\n  }; // Middleware\n\n\n  return function stylus(req, res, next) {\n    if ('GET' != req.method && 'HEAD' != req.method) return next();\n    var path = url.parse(req.url).pathname;\n\n    if (/\\.css$/.test(path)) {\n      if (typeof dest == 'string') {\n        // check for dest-path overlap\n        var overlap = compare(dest, path).length;\n        if ('/' == path.charAt(0)) overlap++;\n        path = path.slice(overlap);\n      }\n\n      var cssPath, stylusPath;\n      cssPath = typeof dest == 'function' ? dest(path) : join(dest, path);\n      stylusPath = typeof src == 'function' ? src(path) : join(src, path.replace('.css', '.styl')); // Ignore ENOENT to fall through as 404\n\n      function error(err) {\n        next('ENOENT' == err.code ? null : err);\n      } // Force\n\n\n      if (force) return compile(); // Compile to cssPath\n\n      function compile() {\n        debug('read %s', cssPath);\n        fs.readFile(stylusPath, 'utf8', function (err, str) {\n          if (err) return error(err);\n          var style = options.compile(str, stylusPath);\n          var paths = style.options._imports = [];\n          imports[stylusPath] = null;\n          style.render(function (err, css) {\n            if (err) return next(err);\n            debug('render %s', stylusPath);\n            imports[stylusPath] = paths;\n            mkdir(dirname(cssPath), {\n              mode: parseInt('0700', 8),\n              recursive: true\n            }, function (err) {\n              if (err) return error(err);\n              fs.writeFile(cssPath, css, 'utf8', next);\n            });\n          });\n        });\n      } // Re-compile on server restart, disregarding\n      // mtimes since we need to map imports\n\n\n      if (!imports[stylusPath]) return compile(); // Compare mtimes\n\n      fs.stat(stylusPath, function (err, stylusStats) {\n        if (err) return error(err);\n        fs.stat(cssPath, function (err, cssStats) {\n          // CSS has not been compiled, compile it!\n          if (err) {\n            if ('ENOENT' == err.code) {\n              debug('not found %s', cssPath);\n              compile();\n            } else {\n              next(err);\n            }\n          } else {\n            // Source has changed, compile it\n            if (stylusStats.mtime > cssStats.mtime) {\n              debug('modified %s', cssPath);\n              compile(); // Already compiled, check imports\n            } else {\n              checkImports(stylusPath, function (changed) {\n                if (debug && changed.length) {\n                  changed.forEach(function (path) {\n                    debug('modified import %s', path);\n                  });\n                }\n\n                changed.length ? compile() : next();\n              });\n            }\n          }\n        });\n      });\n    } else {\n      next();\n    }\n  };\n};\n/**\n * Check `path`'s imports to see if they have been altered.\n *\n * @param {String} path\n * @param {Function} fn\n * @api private\n */\n\n\nfunction checkImports(path, fn) {\n  var nodes = imports[path];\n  if (!nodes) return fn();\n  if (!nodes.length) return fn();\n  var pending = nodes.length,\n      changed = [];\n  nodes.forEach(function (imported) {\n    fs.stat(imported.path, function (err, stat) {\n      // error or newer mtime\n      if (err || !imported.mtime || stat.mtime > imported.mtime) {\n        changed.push(imported.path);\n      }\n\n      --pending || fn(changed);\n    });\n  });\n}\n/**\n * get the overlaping path from the end of path A, and the begining of path B.\n *\n * @param {String} pathA\n * @param {String} pathB\n * @return {String}\n * @api private\n */\n\n\nfunction compare(pathA, pathB) {\n  pathA = pathA.split(sep);\n  pathB = pathB.split('/');\n  if (!pathA[pathA.length - 1]) pathA.pop();\n  if (!pathB[0]) pathB.shift();\n  var overlap = [];\n\n  while (pathA[pathA.length - 1] == pathB[0]) {\n    overlap.push(pathA.pop());\n    pathB.shift();\n  }\n\n  return overlap.join('/');\n}","map":{"version":3,"sources":["/Users/timurmishiev/burger-hub-frontend/node_modules/stylus/lib/middleware.js"],"names":["stylus","require","semver","fs","url","dirname","join","sep","debug","mkdir","satisfies","process","version","imports","module","exports","options","src","force","Error","dest","compile","str","path","sourcemap","inline","set","compress","firebug","linenos","req","res","next","method","parse","pathname","test","overlap","compare","length","charAt","slice","cssPath","stylusPath","replace","error","err","code","readFile","style","paths","_imports","render","css","mode","parseInt","recursive","writeFile","stat","stylusStats","cssStats","mtime","checkImports","changed","forEach","fn","nodes","pending","imported","push","pathA","pathB","split","pop","shift"],"mappings":"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","sourcesContent":["/*!\n * Stylus - middleware\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar stylus = require('./stylus')\n  , semver = require('semver')\n  , fs = require('fs')\n  , url = require('url')\n  , dirname = require('path').dirname\n  , join = require('path').join\n  , sep = require('path').sep\n  , debug = require('debug')('stylus:middleware')\n  , mkdir = semver.satisfies(process.version, '>=10.12.0') ? fs.mkdir : require('mkdirp');\n\n/**\n * Import map.\n */\n\nvar imports = {};\n\n/**\n * Return Connect middleware with the given `options`.\n *\n * Options:\n *\n *    `force`     Always re-compile\n *    `src`       Source directory used to find .styl files,\n *                a string or function accepting `(path)` of request.\n *    `dest`      Destination directory used to output .css files,\n *                a string or function accepting `(path)` of request,\n *                when undefined defaults to `src`.\n *    `compile`   Custom compile function, accepting the arguments\n *                `(str, path)`.\n *    `compress`  Whether the output .css files should be compressed\n *    `firebug`   Emits debug infos in the generated CSS that can\n *                be used by the FireStylus Firebug plugin\n *    `linenos`   Emits comments in the generated CSS indicating\n *                the corresponding Stylus line\n *    'sourcemap' Generates a sourcemap in sourcemaps v3 format\n *\n * Examples:\n *\n * Here we set up the custom compile function so that we may\n * set the `compress` option, or define additional functions.\n *\n * By default the compile function simply sets the `filename`\n * and renders the CSS.\n *\n *      function compile(str, path) {\n *        return stylus(str)\n *          .set('filename', path)\n *          .set('compress', true);\n *      }\n *\n * Pass the middleware to Connect, grabbing .styl files from this directory\n * and saving .css files to _./public_. Also supplying our custom `compile` function.\n *\n * Following that we have a `static()` layer setup to serve the .css\n * files generated by Stylus.\n *\n *      var app = connect();\n *\n *      app.middleware({\n *          src: __dirname\n *        , dest: __dirname + '/public'\n *        , compile: compile\n *      })\n *\n *      app.use(connect.static(__dirname + '/public'));\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(options){\n  options = options || {};\n\n  // Accept src/dest dir\n  if ('string' == typeof options) {\n    options = { src: options };\n  }\n\n  // Force compilation\n  var force = options.force;\n\n  // Source dir required\n  var src = options.src;\n  if (!src) throw new Error('stylus.middleware() requires \"src\" directory');\n\n  // Default dest dir to source\n  var dest = options.dest || src;\n\n  // Default compile callback\n  options.compile = options.compile || function(str, path){\n    // inline sourcemap\n    if (options.sourcemap) {\n      if ('boolean' == typeof options.sourcemap)\n        options.sourcemap = {};\n      options.sourcemap.inline = true;\n    }\n\n    return stylus(str)\n      .set('filename', path)\n      .set('compress', options.compress)\n      .set('firebug', options.firebug)\n      .set('linenos', options.linenos)\n      .set('sourcemap', options.sourcemap);\n  };\n\n  // Middleware\n  return function stylus(req, res, next){\n    if ('GET' != req.method && 'HEAD' != req.method) return next();\n    var path = url.parse(req.url).pathname;\n    if (/\\.css$/.test(path)) {\n\n      if (typeof dest == 'string') {\n        // check for dest-path overlap\n        var overlap = compare(dest, path).length;\n        if ('/' == path.charAt(0)) overlap++;\n        path = path.slice(overlap);\n      }\n\n      var cssPath, stylusPath;\n      cssPath = (typeof dest == 'function')\n        ? dest(path)\n        : join(dest, path);\n      stylusPath = (typeof src == 'function')\n        ? src(path)\n        : join(src, path.replace('.css', '.styl'));\n\n      // Ignore ENOENT to fall through as 404\n      function error(err) {\n        next('ENOENT' == err.code\n          ? null\n          : err);\n      }\n\n      // Force\n      if (force) return compile();\n\n      // Compile to cssPath\n      function compile() {\n        debug('read %s', cssPath);\n        fs.readFile(stylusPath, 'utf8', function(err, str){\n          if (err) return error(err);\n          var style = options.compile(str, stylusPath);\n          var paths = style.options._imports = [];\n          imports[stylusPath] = null;\n          style.render(function(err, css){\n            if (err) return next(err);\n            debug('render %s', stylusPath);\n            imports[stylusPath] = paths;\n            mkdir(dirname(cssPath), { mode: parseInt('0700', 8), recursive: true }, function(err){\n              if (err) return error(err);\n              fs.writeFile(cssPath, css, 'utf8', next);\n            });\n          });\n        });\n      }\n\n      // Re-compile on server restart, disregarding\n      // mtimes since we need to map imports\n      if (!imports[stylusPath]) return compile();\n\n      // Compare mtimes\n      fs.stat(stylusPath, function(err, stylusStats){\n        if (err) return error(err);\n        fs.stat(cssPath, function(err, cssStats){\n          // CSS has not been compiled, compile it!\n          if (err) {\n            if ('ENOENT' == err.code) {\n              debug('not found %s', cssPath);\n              compile();\n            } else {\n              next(err);\n            }\n          } else {\n            // Source has changed, compile it\n            if (stylusStats.mtime > cssStats.mtime) {\n              debug('modified %s', cssPath);\n              compile();\n            // Already compiled, check imports\n            } else {\n              checkImports(stylusPath, function(changed){\n                if (debug && changed.length) {\n                  changed.forEach(function(path) {\n                    debug('modified import %s', path);\n                  });\n                }\n                changed.length ? compile() : next();\n              });\n            }\n          }\n        });\n      });\n    } else {\n      next();\n    }\n  }\n};\n\n/**\n * Check `path`'s imports to see if they have been altered.\n *\n * @param {String} path\n * @param {Function} fn\n * @api private\n */\n\nfunction checkImports(path, fn) {\n  var nodes = imports[path];\n  if (!nodes) return fn();\n  if (!nodes.length) return fn();\n\n  var pending = nodes.length\n    , changed = [];\n\n  nodes.forEach(function(imported){\n    fs.stat(imported.path, function(err, stat){\n      // error or newer mtime\n      if (err || !imported.mtime || stat.mtime > imported.mtime) {\n        changed.push(imported.path);\n      }\n      --pending || fn(changed);\n    });\n  });\n}\n\n/**\n * get the overlaping path from the end of path A, and the begining of path B.\n *\n * @param {String} pathA\n * @param {String} pathB\n * @return {String}\n * @api private\n */\n\nfunction compare(pathA, pathB) {\n  pathA = pathA.split(sep);\n  pathB = pathB.split('/');\n  if (!pathA[pathA.length - 1]) pathA.pop();\n  if (!pathB[0]) pathB.shift();\n  var overlap = [];\n\n  while (pathA[pathA.length - 1] == pathB[0]) {\n    overlap.push(pathA.pop());\n    pathB.shift();\n  }\n  return overlap.join('/');\n}\n"]},"metadata":{},"sourceType":"script"}